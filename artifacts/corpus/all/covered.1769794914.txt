/src/contracts/Lottery.sol
      pragma solidity ^0.8.22;
      // SPDX-License-Identifier: UNLICENSED
      import "./Taxpayer.sol";
      
      contract Lottery {
      address owner;
      mapping (address => bytes32) commits;
      mapping (address => uint) reveals;
      address[] revealed;
      
      uint256 startTime;
      uint256 revealTime;
      uint256 endTime;
      uint256 period;
      bool iscontract;
      
      // Initialize the registry with the lottery period.
       constructor(uint p) {
        period = p;
        startTime = 0;
        endTime = 0;
        iscontract=true;
       } 
      
      
      //If the lottery has not started, anyone can invoke a lottery.
      function startLottery() public {
        require (startTime == 0);
        //startTime current time. Users send their committed value
        startTime = block.timestamp;
        //revealTime  time for revealing. User reveal their value
        revealTime = startTime+period;
        //endTime a winner can be computed
        endTime = revealTime+period;
      }
      
      //A taxpayer send his own commitment. 
      function commit(bytes32 y) public {
        require(block.timestamp >= startTime);
        commits[msg.sender] = y;
      }
      
      //A valid taxpayer who sent his own commitment, sends the revealing value.
      function reveal(uint256 rev) public {
        require(block.timestamp >= revealTime);
        require(keccak256(abi.encode(rev))==commits[msg.sender]);
        revealed.push(msg.sender);
        reveals[msg.sender] = uint(rev);
        
      }
      
      //Ends the lottery and compute the winner.
      function endLottery() public {
        require(block.timestamp >= endTime);
        uint total = 0;
        for (uint i = 0; i < revealed.length; i++)
          total+= reveals[revealed[i]];
        Taxpayer(revealed[total%revealed.length]).setTaxAllowance(7000);
        startTime = 0;
        revealTime=0;
        endTime = 0;
      }
        function isContract() public view returns(bool) {
          return iscontract;
        }
      
      }
      

/src/contracts/Taxpayer.sol
      pragma solidity ^0.8.22;
      
      import "./Lottery.sol";
      
      contract Taxpayer {
      
        uint age; 
      
        bool isMarried; 
      
        bool iscontract;
      
        address spouse; 
      
      
        address  parent1; 
        address  parent2; 
      
 *      uint constant  DEFAULT_ALLOWANCE = 5000;
      
        uint constant ALLOWANCE_OAP = 7000;
      
        uint tax_allowance; 
      
        uint income; 
      
        uint256 rev;
      
      
 *      constructor(address p1, address p2) {
 *        age = 0;
 *        isMarried = false;
 *        parent1 = p1;
 *        parent2 = p2;
 *        spouse = address(0);
 *        income = 0;
 *        tax_allowance = DEFAULT_ALLOWANCE;
 *        iscontract = true;
        } 
      
      
 *      function marry(address new_spouse) public {
 *        require(new_spouse != address(0), "invalid spouse");
 *        require(new_spouse != address(this), "self marriage");
 *        require(!isMarried && spouse == address(0), "already married");
      
 *        Taxpayer sp = Taxpayer(new_spouse);
      
 *        require(!sp.getIsMarriedForSSA(), "spouse already married");
 *        require(sp.getSpouseForSSA() == address(0), "spouse already married");
      
 *        spouse = new_spouse;
 *        isMarried = true;
      
 *        sp.marryBack(address(this));
      
        }
      
 *      function marryBack(address other) public {
 *        require(msg.sender == other, "only spouse");
 *        require(other != address(0) && other != address(this), "invalid other");
 *        require(!isMarried && spouse == address(0), "already married");
      
 *        spouse = other;
 *        isMarried = true;
      }
      
 *      function _baselineAllowance() internal view returns (uint) {
 *        return (age >= 65) ? ALLOWANCE_OAP : DEFAULT_ALLOWANCE;
        }
      
 *      function _refreshAllowanceFloor() internal {
 *          uint base = _baselineAllowance();
 *          if (tax_allowance < base) {
                tax_allowance = base;
            }
        }
       
 *      function divorce() public {
 *        if (spouse != address(0)) {
 *          address old = spouse;
 *          Taxpayer oldTp = Taxpayer(old);
      
 *          require(oldTp.getSpouseForSSA() == address(this), "not reciprocal");
      
 *          spouse = address(0);
 *          isMarried = false;
      
 *          tax_allowance = _baselineAllowance();
      
 *          oldTp.divorceBack(address(this));
          } else {
            spouse = address(0);
            isMarried = false;
            tax_allowance = _baselineAllowance();
          }
        } 
      
 *      function divorceBack(address expectedSpouse) public {
 *        require(msg.sender == expectedSpouse, "only spouse");
 *        require(spouse == expectedSpouse, "not reciprocal");
      
 *        spouse = address(0);
 *        isMarried = false;
      
 *        tax_allowance = _baselineAllowance();
        }
      
        function divorceBack() public {
          divorceBack(msg.sender);
        }
      
      
        function transferAllowance(uint change) public {
            require(isMarried, "not married");
            require(spouse != address(0), "no spouse");
            require(change > 0, "zero");
            require(change <= tax_allowance, "insufficient");
      
            if (age >= 65) {
                require(tax_allowance - change >= ALLOWANCE_OAP, "OAP min allowance");
            }
      
            Taxpayer sp = Taxpayer(spouse);
      
            require(sp.isContract(), "spouse not contract");
            require(sp.getSpouseForSSA() == address(this), "not reciprocal");
      
            tax_allowance -= change;
      
            sp.setTaxAllowance(sp.getTaxAllowance() + change);
        }
      
 *      function haveBirthday() public {
 *        age++;
 *        _refreshAllowanceFloor();
      
        }
      
        function setTaxAllowance(uint ta) public {
          require(Taxpayer(msg.sender).isContract() || Lottery(msg.sender).isContract());
      
          uint base = _baselineAllowance();
          if (ta < base) {
            tax_allowance = base;
          } else {
            tax_allowance = ta;
          }
        }
      
 *      function getTaxAllowance() public view returns(uint) {
 *        return tax_allowance;
      
        }
      
        function isContract() public view returns(bool){
          return iscontract;
      
        }
      
        function joinLottery(address lot, uint256 r) public {
          Lottery l = Lottery(lot);
          l.commit(keccak256(abi.encode(r)));
          rev = r;
      
        }
      
        function revealLottery(address lot, uint256 r) public {
          Lottery l = Lottery(lot);
          l.reveal(r);
          rev = 0;
      
        }
      
 *      function getSpouseForSSA() public view returns (address) {
 *        return spouse;
        }
      
 *      function getIsMarriedForSSA() public view returns (bool) {
 *        return isMarried;
        }
      
      }
      

/src/tests/echidna/Echidna_All.sol
      // SPDX-License-Identifier: UNLICENSED
      pragma solidity ^0.8.22;
      
      import "./TaxpayerHarness.sol";
      
 *    contract Echidna_All {
          TaxpayerHarness internal A;
          TaxpayerHarness internal B;
      
 *        constructor() {
 *            A = new TaxpayerHarness(address(0), address(0));
 *            B = new TaxpayerHarness(address(0), address(0));
          }
      
 *        function _baseline(uint256 age) internal pure returns (uint256) {
 *            return (age >= 65) ? 7000 : 5000;
          }
      
 *        function _pick(uint8 who) internal view returns (TaxpayerHarness) {
 *            return (who % 2 == 0) ? A : B;
          }
      
 *        function _other(TaxpayerHarness t) internal view returns (TaxpayerHarness) {
 *            return (address(t) == address(A)) ? B : A;
          }
      
 *        function _marriedReciprocal() internal view returns (bool) {
 *            return (A.getSpouse() == address(B)) &&
 *                (B.getSpouse() == address(A)) &&
 *                A.getIsMarried() &&
 *                B.getIsMarried();
          }
      
 *        function act_marry(uint8 who) public {
 *            TaxpayerHarness x = _pick(who);
 *            TaxpayerHarness y = _other(x);
      
 *            if (x.getIsMarried() || y.getIsMarried()) return;
 *            if (x.getSpouse() != address(0) || y.getSpouse() != address(0)) return;
      
 *            x.marry(address(y));
          }
      
 *        function act_divorce(uint8 who) public {
 *            TaxpayerHarness x = _pick(who);
 *            if (!x.getIsMarried()) return;
 *            x.divorce();
          }
      
 *        function act_transfer(uint8 who, uint256 raw) public {
 *            TaxpayerHarness x = _pick(who);
 *            TaxpayerHarness y = _other(x);
      
 *            if (!_marriedReciprocal()) return;
 *            if (x.getSpouse() != address(y)) return;
      
 *            uint256 allowance = x.getTaxAllowance();
 *            uint256 floor = _baseline(x.getAge());
      
 *            if (allowance <= floor) return;
      
              uint256 maxSend = allowance - floor;
              uint256 amount = (raw % maxSend) + 1;
      
              x.transferAllowance(amount);
          }
      
 *        function act_age(uint8 who, uint256 times) public {
 *            TaxpayerHarness x = _pick(who);
 *            uint256 t = times % 5;
 *            for (uint256 k = 0; k < t; k++) {
 *                x.haveBirthday();
              }
          }
      
          function echidna_all_no_self_marriage() public view returns (bool) {
              return (A.getSpouse() != address(A)) && (B.getSpouse() != address(B));
          }
      
          function echidna_all_symmetry() public view returns (bool) {
              if (A.getSpouse() != address(0) && A.getSpouse() != address(B)) return false;
              if (B.getSpouse() != address(0) && B.getSpouse() != address(A)) return false;
      
              if (A.getSpouse() == address(B) && B.getSpouse() != address(A)) return false;
              if (B.getSpouse() == address(A) && A.getSpouse() != address(B)) return false;
      
              return true;
          }
      
          function echidna_all_unmarried_baseline() public view returns (bool) {
              if (A.getSpouse() == address(0)) {
                  if (A.getTaxAllowance() != _baseline(A.getAge())) return false;
              }
              if (B.getSpouse() == address(0)) {
                  if (B.getTaxAllowance() != _baseline(B.getAge())) return false;
              }
              return true;
          }
      
          function echidna_all_oap_min_7000() public view returns (bool) {
              if (A.getAge() >= 65 && A.getTaxAllowance() < 7000) return false;
              if (B.getAge() >= 65 && B.getTaxAllowance() < 7000) return false;
              return true;
          }
      
          function echidna_all_pooling_sum_equals_baseline_sum() public view returns (bool) {
              if (!_marriedReciprocal()) return true;
      
              uint256 sum = A.getTaxAllowance() + B.getTaxAllowance();
              uint256 baseSum = _baseline(A.getAge()) + _baseline(B.getAge());
              return sum == baseSum;
          }
      }

/src/tests/echidna/TaxpayerHarness.sol
      // SPDX-License-Identifier: UNLICENSED
      pragma solidity ^0.8.22;
      
      import "../../contracts/Taxpayer.sol";
      
 *    contract TaxpayerHarness is Taxpayer {
 *        constructor(address p1, address p2) Taxpayer(p1, p2) {}
      
 *        function getSpouse() external view returns (address) {
 *            return spouse;
          
          }
      
 *        function getIsMarried() external view returns (bool) {
 *            return isMarried;
          
          }
      
 *        function getAge() external view returns (uint) {
 *            return age;
      
          }
      }

